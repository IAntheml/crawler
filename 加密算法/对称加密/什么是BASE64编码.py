"""
Base64编码表用了64个字符：A-Z、a-z、0-9、+ 、/，刚好是2的6次方，这也是Base64的由来，Base64每个字符用6个比特位来表示。最后还有一个=用作特殊用途，稍后会介绍，所以Base64编码表共有65个字符。

编码规则
首先将二进制数据按每6个比特位为一组编译成一个Base64的编码表中对应的一个字符。解码就是将Base64的字符依次还原回6位的比特位，以此得到原始的二进制数据了。

例子
编码：

待编码字符：Man
对应的二进制：M（01001101）a（01100001）n（01101110）
即01001101 01100001 01101110
按每6个比特位为一组来对二进制进行划分：010011 010110 000101 101110
将6位进制编译成Base64对应的字符：T W F u，那么Man的Base64编码结果就是TWFu了。
解码：
解码就是上面过程的逆过程。按Base64编码表，将Base64字符解码出对应的6位二进制，进而得到原始的二进制数据。

例外
在编码的过程种有三种情况需要特殊处理一下。

第一种：待编码的二进制只有24位，此时刚好能分成4组，编码结果就是4个字符，没有=号，如Man有24位二进制，结果就是TWFu。
第二种：待编码的二进制只有16位，那么编码的结果就是3个字符跟上一个=号，如Ma：
Ma的二进制：01001101 01100001
分组结果：010011 010110 0001
根据​​RFC-4648​​的规范，对于这种情况，将在最后用0补齐6位，得到：010011 010110 000100
对应Base64的编码就是TWE，为了能在解码时能识别出最后有补齐的两个0，以便去掉，要跟上=作记号，所以Ma最终的Base64编码就是TWE=。
第三种：待编码的二进制只有8位，Base64编码结果应该是两个字符，跟上两个=号，如M：
M的二进制：01001101
分组结果：010011 01
根据​​RFC-4648​​的规范，对于这种情况，将在最后用0补齐6位，得到：010011 010000
对应Base64的编码就是TQ，为了能在解码时能识别出最后有补齐的4个0，以便去掉，要跟上两个=作记号，所以M最终的Base64编码就是TQ==，
原文链接：https://blog.csdn.net/weixin_40763897/article/details/126314371


补充1：一个字节8位，一组BSE64编码6位，最小公倍数为24即3个字节，任何数据与3字节求余都是1或者2，当余1时，剩余8位，需要补充4个零即两个==，当余2时，剩余16位，需要补充2位即一个=

补充2：一个字节有8位，而一个16进制数占4位，所以8位可以表示2个16进制数。
"""